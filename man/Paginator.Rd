% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/paginator.R
\docType{data}
\name{Paginator}
\alias{Paginator}
\title{Paginator client}
\arguments{
\item{client}{an object of class \code{HttpClient}, from a call to \link{HttpClient}}

\item{by}{(character) how to paginate. One of query_params, link_headers,
or cursor. See Details.}

\item{limit_chunk}{(numeric/integer) the number by which to chunk requests,
e.g., 10 would be be each request gets 10 records}

\item{limit_param}{(character) the name of the limit parameter.
Default: limit}

\item{offset_param}{(character) the name of the offset parameter.
Default: offset}

\item{limit}{(numeric/integer) the maximum records wanted}
}
\value{
a list, with objects of class \code{\link[=HttpResponse]{HttpResponse()}}.
Responses are returned in the order they are passed in.
}
\description{
A client help you paginate, a wrapper around \link{HttpClient}
}
\details{
\strong{Methods}
\describe{
\item{\code{get(path, query, ...)}}{
make a paginated GET request
}
\item{\code{post(path, query, body, encode, ...)}}{
make a paginated POST request
}
\item{\code{put(path, query, body, encode, ...)}}{
make a paginated PUT request
}
\item{\code{patch(path, query, body, encode, ...)}}{
make a paginated PATCH request
}
\item{\code{delete(path, query, body, encode, ...)}}{
make a paginated DELETE request
}
\item{\code{head(path, ...)}}{
make a paginated HEAD request
}
\item{\code{responses()}}{
list responses
- returns: a list of \code{HttpResponse} objects, empty list before
requests made
}
\item{\code{parse(encoding = "UTF-8")}}{
parse content
- returns: character vector, empty character vector before
requests made
}
\item{\code{status_code()}}{
(integer) HTTP status codes
- returns: numeric vector, empty numeric vector before
requests made
}
\item{\code{status()}}{
(list) HTTP status objects
- returns: a list of \code{http_code} objects, empty list before
requests made
}
\item{\code{content()}}{
raw content
- returns: raw list, empty list before requests made
}
\item{\code{times()}}{
curl request times
- returns: list of named numeric vectors, empty list before
requests made
}
}

See \code{\link[=HttpClient]{HttpClient()}} for information on parameters.
}
\section{Methods to paginate}{

\itemize{
\item \code{query_params}: the most common way, so is the default. This method
involves setting how many records and what record to start at for each
request. We send these query parameters for you.
\item \code{link_headers}: link headers are URLS for the next/previous/last
request given in the response header from the server. This is relatively
uncommon, though is recommended by JSONAPI and is implemented by a
well known API (GitHub).
\item \code{cursor}: this works by a single string given back in each response, to
be passed in the subsequent response, and so on until no more records
remain. This is common in Solr
}
}

\examples{
\dontrun{
# by query parameters (here limit and skip for CouchDB)
(cli <- HttpClient$new(url = "http://localhost:5984"))
cc <- Paginator$new(client = cli, by = "query_params", limit_param = "limit",
   offset_param = "skip", limit_chunk = 5, limit = 100)
cc
#cc$requests()
cli$get('omdb/_all_docs', query = list(limit = 3))$parse("UTF-8")
cc$get('omdb/_all_docs')
cc
cc$responses()
cc$status()
cc$status_code()
cc$times()
cc$content()
cc$parse()
lapply(cc$parse(), jsonlite::fromJSON)

# by link headers: GitHub
## eg to come

# by cursor: Crossref
## eg to come
}
}
\keyword{datasets}
